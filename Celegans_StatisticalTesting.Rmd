---
title: "Celegans_StatisticalTesting"
author: "Lauren Shelby, Selena Gupta, Manny Katari"
date: "2024-02-26"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(ggplot2)
library(tidyverse)
library(dplyr)
```

These tests are based on the *C. elegans* whole-embryo timecourse data from 
Hashimshony et al., 2014.

Our objective is to understand what type of genes are peaking in expression 
at different times of embryo timecourse.

The data is already normalized using the TPM method but for the sake of some
of the statistical tests we will assume that the data is normally distributed.

## Loading the Dataset 

```{r}
# reading the file into emb_xpr
emb_xpr <- read.csv("C_elegans_whole_embryo.csv")

# The data frame has 20517 rows 
# The data frame has 52 columns 
# The rows represent a particular gene, and the columns hold the gene name, gene ID, and 50 time points. 
# The values in each cell represent the expression level of a particular gene at a particular time point in embryonic development starting at fertilization.
```

## Cleaning the Data

```{r}
head(emb_xpr)

# Initializing a variable to hold the number of genes with a total count less than or equal to 50
genecount <- 0
# Creating a loop to go through each gene and add up its expression levels, if the total expression level count is less than or equal to 50 it will add one to the genecount variable 
for (i in 1:nrow(emb_xpr)) {
  if (rowSums(emb_xpr[i,3:52])<=50){
    genecount <- genecount + 1 
  }
}
genecount

# Setting a new cleaned data set 'emb_xpr' equal to the original data set, then filtering the data so that the total expression counts that are less than 50 are removed 

emb_xpr.clean <- emb_xpr
emb_xpr.clean <- emb_xpr.clean %>% 
  filter(rowSums(emb_xpr.clean[,3:52])>50)
```

## Look at the distribution of the values in the dataset.

Scaling the data with the Log2() function. 

```{r}
# Creating histogram for all expression values 

emb_xpr.clean.melt <- pivot_longer(emb_xpr.clean, 3:52)

ggplot(data = emb_xpr.clean.melt) + 
  geom_histogram(mapping = aes(x = log2(value))) +
  xlab("Scaled gene expression count") +
  ylab("Frequency")
```

## Making a heatmap of the raw (cleaned) data.



```{r}
# Creating a heat map for the raw expression data
ggplot(data = emb_xpr.clean.melt) +
  geom_tile(mapping = aes(x = name, y = Gene, fill = log2(value))) + #name stands for the time point
  scale_fill_gradientn(colours = topo.colors(50)) + 
  guides(fill = guide_colorbar(title = "Scaled expression value")) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
  labs(x = "Time into Development")
```

## Filtering the data for dynamically expressed genes.

In the paper, the authors looked for all genes that had at least one value < 10 and another > 100.
We will be a little more discriminating by selecting the set of genes from "emb_xpr.clean.melt" whose *minimum expression is less than 10 TPM* and whose *maximum expression is at least 500 TPM*. I am saving the genes that satisfy these criteria in a data frame called **dynamic_genes**.

```{r}
# Getting the minimum and maximum expression levels for each gene in the emb_xpr.clean data and storing them in max_xpr and min_xpr vectors with the corresponding gene name
max_xpr <- c() 
for (i in 1:length(emb_xpr.clean$Gene)) {
  max_xpr <- append(max_xpr, max(emb_xpr.clean[i,3:52]))
}
names(max_xpr) <- emb_xpr.clean$Gene

min_xpr <- c()
for (i in 1:length(emb_xpr.clean$Gene)) {
  min_xpr <- append(min_xpr, min(emb_xpr.clean[i,3:52]))
}
names(min_xpr) <- emb_xpr.clean$Gene

# Using min_xpr and max_xpr to filter the emb_xpr.clean data for the genes where the minimum expression is less than 10 and the max expression is greater than or equal to 500. Storing those genes in a data frame called dynamic_genes
dynamic_genes <- data.frame() 
for (i in 1:length(max_xpr)) {
  if (min_xpr[i]<10 & max_xpr[i]>=500) {
    dynamic_genes <- rbind(dynamic_genes, emb_xpr.clean[i,])
  }
}

# Melting the filtered data so that all expression levels for each gene are in the same column
dynamic_genes_melted <- pivot_longer(dynamic_genes, 3:52)

# Creating a heatmap of these dynamic genes 
ggplot(data = dynamic_genes_melted) + 
  geom_tile(mapping = aes(x = name, y = Gene, fill = log2(value))) +
  scale_fill_gradientn(colours = topo.colors(50)) + 
  guides(fill = guide_colorbar(title = "Scaled expression value")) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
  labs(x = "Time into Development")
```


## Making a heatmap of dynamic genes sorted by their time of maximum expression.

Sorting the "dynamic_genes" by the time at which they display their maximum
expression and make a heatmap of the **sorted and log-transformed** data.

```{r}
# Creating a variable that stores the column index of the max expression value for each gene in dynamic_genes data frame
max_exp_index <- max.col(dynamic_genes[3:52], ties.method = "first")

#Adding a column to dynamic_genes that holds the index of the maximum expression value of each gene
dynamic_genes <- cbind(dynamic_genes, max_exp_index)

# Ordering the dynamic_genes data frame from earliest to latest time where the genes show their maximum expression
dynamic_genes <- dynamic_genes[order(dynamic_genes$max_exp_index),]

# Melting the data so that all of the expression levels are in one column
dynamic_genes_melted <- pivot_longer(dynamic_genes, 3:52)

ggplot(data = dynamic_genes_melted) + 
  geom_tile(mapping = aes(x = name, y = Gene, fill = log2(value))) +
  scale_fill_gradientn(colours = topo.colors(50)) + 
  guides(fill = guide_colorbar(title = "Scaled expression value")) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
  labs(x = "Time into Development") 
```

## PCA analysis

We do not have replicates for each time point, so lets see if the time points
can be grouped and we treat the members of the groups as pseudo-replicates
even though they are not.

```{r}
library(GEOquery)

#Creating the PCA for the ordered dynamic_genes data frame 
dg_scaled <- scale(dynamic_genes[,3:52]) 

pca_dg <- prcomp(dg_scaled)

pca_result <- data.frame(pca_dg$x, Time = dynamic_genes_melted$name)
head(pca_result)

#Creating a plot that displays the results of PC1 and PC2, colored by the time points 
ggplot(data = pca_result) + 
  geom_point(mapping = aes(x = PC1, y = PC2, color = Time))
```

## Now let's cluster the time points into groups 

Using the dynamic genes, I'm performing a pairwise correlation between all time points.

```{r}
library(reshape2)
library(cluster)

# Getting pairwise correlation between time points 
dynamic_cor <- cor(dynamic_genes[,3:52])

# Calculating a hierarchical cluster with the 'average' method 
dynamic_dist <- as.dist(1-dynamic_cor)
dynamic_cluster <- hclust(dynamic_dist, method = "average")

# We can use the 'cutree' function to create cluster groups of data points for us, and we get the optimal number of groups by looking at the optimal silhouette of different sized groups. 
# Getting the average silhouette width for clusters from 2-20 groups by looping through each number of groups and using the 'silhouette' and 'cutree' function with the clustered data we calculated above to simulate each number of groups 
avg_sil <- c() 
for (i in 2:20) {
  avg_sil <- append(avg_sil, mean(silhouette(cutree(dynamic_cluster, k = i), dist = dynamic_dist)))
}

# Plotting the average silhouette width for each number of groups 
ggplot() + 
  geom_point(mapping = aes(x = 2:20, y = avg_sil)) + 
  labs(x = "Number of Groups", y = "Average Silhouette Width")

# The optimal k is usually where the width is the largest while still having a reasonable amount of clusters. Since here the width increases with each incremental amount of groups, it's really our choice what is best. 

# Cutting the cluster above into 5 groups and saving to 'expgroup' data frame 

dynamic_expgroup <- cutree(dynamic_cluster, k = 5) 
expgroup <- data.frame(dynamic_expgroup)
colnames(expgroup) <- "Group"
```

## Performing a statistical analysis to identify differentially expressed genes

Assuming the data is normally distributed and the variance is equal, performing 
a t-test for each gene in the emb_xpr.clean data frame.

```{r}
library(broom)

# If we are assuming the data is normally distributed and the variance is equal, then we can perform a t-test on the expression levels in each gene to determine if there are significantly differentially expressed genes. 

# I'm looping through each gene in the 'emb_xpr.clean' data set and performing a t.test on the expression levels then storing the data from that in the 'exp_pvals' data frame 
exp_pvals <- data.frame() 
for (i in 1:length(emb_xpr.clean$Gene)) {
  exp_pvals <- rbind(exp_pvals, tidy(t.test(emb_xpr.clean[i,3:52])))
}
```

Plotting a histogram of all p-values.

```{r}
# Histogram of all p-values 
ggplot(data = exp_pvals) +
  geom_histogram(mapping = aes(x = p.value)) +
  xlim(0.0,0.2)+ 
  ylim(0,750)

# Out of the 12127 genes in the 'emb_xpr.clean' data set, 11063 of them are less than or equal to the 0.01 cutoff according to the loop below that loops through each p-value and collects if it is less than or equal to 0.01. 
total_pvals <- 0
for (i in 1:length(emb_xpr.clean$Gene)) {
  if (exp_pvals[i,3]<=0.01) {
    total_pvals = total_pvals + 1
  }
}
```


```{r}
## Calculating False Discovery Rate (FDR) using the formula FDR = FalsePositive / (FalsePositive + TruePositive)

# Calculating percent of genes below 0.01 cutoff
percent_pval <- total_pvals/length(emb_xpr.clean$Gene)

# Calculating the expected number of genes shouldbe below the 0.01 p-value cutoff 
actual_pval <- 0.01*length(emb_xpr.clean$Gene)

# Calculating the number of false positives by subtracting the actual number we should see below 0.01 by the total number of genes observed below the p-value 
false_positive <- total_pvals - actual_pval

# Calculating false discovery rate from the formula above 
false_discovery_rate <- false_positive / total_pvals
false_discovery_rate
```

Performing the correction with a q-value cutoff of 0.01.

```{r}
# With the actual number of values that should be significant stored in actual_pval, I am storing the genes with the lowest p-values below the actual_pval threshold in a vector called siggenes

exp_pvals <- cbind(exp_pvals, emb_xpr.clean$Gene)

exp_pvals <- exp_pvals[order(exp_pvals$p.value, decreasing = F),]

siggenes <- c(exp_pvals[1:total_pvals,3])
names(siggenes) <- exp_pvals[1:total_pvals,9]
```

## Checking for significant overlap of dynamic genes and significant genes

```{r}
# Seeing if there are any overlaps between siggenes and dynamic genes by creating a nested loop to parse through each individual gene in siggenes and compare that to each individual dynamic gene. There are 737 overlapping genes. 
overlap <- 0 
for (i in 1:length(siggenes)) {
  for (j in 1:length(dynamic_genes$Gene)) {
    if (names(siggenes[i]) == dynamic_genes[j,1]) {
      overlap = overlap + 1
    }
  }
}
overlap
```


```{r}
# Determining whether the overlap is significant with a hypergeometric distribution 
phyper(overlap, length(siggenes), length(emb_xpr.clean$Gene)-length(siggenes), length(dynamic_genes$Gene))
# Yes, the overlap is statistically significant because the p-value is 2.0E-08 
```

## Clustering the overlapping genes.

Subseting the dynamic genes data with genes in common between the lists.
Creating a new dataframe with just the genes that overlap the different lists. 

```{r}
# Creating a nested loop that goes through siggenes and dynamic_genes and compares the gene names. If the gene names are the same the loop appends the row from dynamic_genes to a new data set called overlapgenes 
overlapgenes <- data.frame() 
for (i in 1:length(siggenes)) {
  for (j in 1:length(dynamic_genes$Gene)) {
    if (names(siggenes[i]) == dynamic_genes[j,1]) {
      overlapgenes <- rbind(overlapgenes, dynamic_genes[j,])
    }
  }
}

# Getting the pairwise correlation between all genes in overlapgenes 
overlap_cor <- cor(t(overlapgenes[,3:52]), method = "pearson")

# Performing hierarchical clustering with the 'average' method 
overlap_dist <- as.dist(1-overlap_cor)
overlap_cluster <- hclust(overlap_dist, method = "average")

# Cutting the clustered tree into 5 groups, and saving grouping data called 'genegroup' 
overlap_genegroup <- cutree(overlap_cluster, k = 5) 
overlap_genegroup
genegroup <- data.frame(overlap_genegroup)
colnames(genegroup) <- "Group"
rownames(genegroup) <- overlapgenes$Gene
```

### Q12: Plotting representative genes

Select 1 gene from each group to plot using geom_smooth function

Discuss the patterns you observe for each group.


```{r}
# Creating a new data frame with my 5 genes of interest as columns and the time points as rows. Selecting 'R06C1.4', 'B0035.1', 'rpl-11.2', 'F58B3.6', and 'lron-11' for groups 1 through 5 respectively. 

selected_genes <- data.frame()
selected_genes <- rbind(selected_genes, overlapgenes[1,3:52]) #R06C1.4
selected_genes <- rbind(selected_genes, overlapgenes[2,3:52]) #B0035.1
selected_genes <- rbind(selected_genes, overlapgenes[17,3:52]) #rpl-11.2
selected_genes <- rbind(selected_genes, overlapgenes[51,3:52]) #F58B3.6
selected_genes <- rbind(selected_genes, overlapgenes[248,3:52]) #lron-11
rownames(selected_genes) <- c("R06C1.4", "B0035.1", "rpl-11.2", "F58B3.6", "lron-11")

# Transforming that data frame to be used more easily in ggplot 
selected_genes <- t(selected_genes)
selected_genes <- as.data.frame(selected_genes)
#selected_genes <- cbind(selected_genes, )

# Plotting the gene 'RO6C1.4' in group 1
ggplot(data = selected_genes) +
  geom_point(mapping = aes(x = 0:49, y = selected_genes[,1])) +
  geom_smooth(mapping = aes(x = 0:49, y = selected_genes[,1])) + 
  labs(x = "Time Point", y = "RO6C1.4 Expression Level")

# In this plot we see two peaks in activity around time point 12 and time point 30.
```


```{r}
# Plotting B0035.1 in group 2 
ggplot(data = selected_genes) +
  geom_point(mapping = aes(x = 0:49, y = selected_genes[,2])) +
  geom_smooth(mapping = aes(x = 0:49, y = selected_genes[,2])) + 
  labs(x = "Time Point", y = "B0035.1 Expression Level")

# In this graph we see the peaks in expression at the beginning then they taper off towards the end. 
```


```{r}
# Plotting rpl-11.2 in group 3 
ggplot(data = selected_genes) +
  geom_point(mapping = aes(x = 0:49, y = selected_genes[,3])) +
  geom_smooth(mapping = aes(x = 0:49, y = selected_genes[,3])) + 
  labs(x = "Time Point", y = "rpl-11.2 Expression Level")

# These expression levels peak at the beginning then get lower as time goes on.
```


```{r}
#Plotting F58B3.6 in group 4 
ggplot(data = selected_genes) +
  geom_point(mapping = aes(x = 0:49, y = selected_genes[,4])) +
  geom_smooth(mapping = aes(x = 0:49, y = selected_genes[,4])) + 
  labs(x = "Time Point", y = "F58B3.6 Expression Level")

# This plot is bell curve shaped and peaks at time point 30.
```


```{r}
#Plotting lron-11 in group 5 
ggplot(data = selected_genes) +
  geom_point(mapping = aes(x = 0:49, y = selected_genes[,5])) +
  geom_smooth(mapping = aes(x = 0:49, y = selected_genes[,5])) + 
  labs(x = "Time Point", y = "lron-11 Expression Level")

#These expression levels stay mostly flat besides a couple of outlier peaks in expression at certain time points.
```

